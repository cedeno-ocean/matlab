function [mac,ar,aic] = armodel(x,k)%% FUNCTION [Mov_Avg_Const,AR_coefs,AIC] = armodel (data_in,max_model_order)%% This routine fits an autoregressive model to the data vector% input in DATA_IN. The maximum model order is also input. The last% output parameter is minimum when the model order is optimal.% See ARINTERP for an example of this routine's use.% % INPUTS :   data_in - The input data vector. Only vectors allowed.%                      The input data must not have gaps.%                      %          max_model_order - The maximum order of the model to be fit.%                      % OUTPUTS: Mov_Avg_Const - The moving average constant.%                      %           AR_coefs - The model coefficients. See routine%                      ARINTERP for an example of how to%                      use the coefficients.%                      %                AIC - The Aikake Information Criterion. This%                      parameter is minimum when the order of %                      the model is optimal from an information%                      theory standpoint.%                       % NOTES  :  1. The algorithms and conventions used are from the%             Numerical Recipes book by Press et al.%              % HISTORY:  1. Version 1 written 27 June 1990 by Gary T. Mitchum.%               % Do not proceed if x has missing values.if sum(isnan(x))~=0;   disp(['Input series cannot have missing data.']); return;end% Set some parameters and demean x.x=x(:); n=length(x); xbar=mean(x); x=x-xbar; ck=.000001;if nargin==1;   maxord=min(20,round(n/10)); maxord=max(maxord,2);else   maxord=k;end% Initialize for iteration (m=1 step).b1=x(1:n-1); b2=x(2:n);a=2*sum(b1.*b2)/sum(b1.*b1+b2.*b2);ar=a; p=mean(x.*x)*(1-ar*ar); wnv=p; mac=xbar*(1-ar);if wnv<ck & nargin==1; aic=-1/ck; return; endaic=(n-1)*log(wnv)+2;if nargin==2; if k==1; return; end; end% Iterate to minimum aic, or to input order.for ord=2:maxord    aa=a; b1t=b1(1:n-ord)-aa(ord-1)*b2(1:n-ord);          b2=b2(2:n-ord+1)-aa(ord-1)*b1(2:n-ord+1); b1=b1t;    a(ord)=2*sum(b1.*b2)/sum(b1.*b1+b2.*b2);    a(1:ord-1)=aa(1:ord-1)-a(ord)*aa(ord-1:-1:1); a=a(:);    ar2=a; p2=p*(1-ar2(ord)*ar2(ord)); wnv2=p2; mac2=xbar*(1-sum(ar2));    if wnv2<ck & nargin==1       aic=-1/ck; wnv=wnv2; p=p2; mac=mac2; ar=ar2; break;    end    aic2=(n-ord)*log(wnv2)+2*ord;    if aic2>aic & nargin==1; break; end    aic=aic2; mac=mac2; wnv=wnv2; ar=ar2;end% Fix roots to insure a stable model.nar=length(ar); zs=roots([1;-ar]);ndex=abs(zs)>1;if sum(ndex)>0; disp(['Fixing roots!'])   zs(ndex)=ones(sum(ndex),1)./conj(zs(ndex)); coef=real(poly(zs));   ar=[-coef(2:nar+1)]';end
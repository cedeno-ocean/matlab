function x=arinterp(y,maxgap,ntrain)%% FUNCTION [dataout] = arinterp (datain,maxgaplen,ntrain)%   This routine interpolates gaps (marked by NaN values) using %   the auto-regressive bridge method. A length of data of length%   <ntrain> on each side of the gap is used to fit an AR model %   extrapolation into the gap. These two extrapolations are%   combined with weighting inversely proportional to the length%   of the extrapolation to yield the interpolation. Routine%   ARModel must be available before running this one.% % INPUTS :    datain - The input dataset. If a matrix is input, %                      interpolation is applied column-wise. The%                      gaps are marked by NaN values.%                      %          maxgaplen - The maximum length gap to interpolate.%                      %             ntrain - The length of data on each side of the%                      gap to use in fitting the AR model. %                      Larger values take more time and may %                      yield strange interpolations. NOTE: you%                      should always visually inspect data%                      after any interpolation is applied.%                      % OUTPUTS:   dataout - Dataset after interpolating where possible.%                      % NOTES  :  1. The <ntrain> parameter controls the character of the%             interpolation, but it is difficult to specify a%             single "good" value. The best thing is to experiment%             with the parameters <ntrain> and <maxgaplen> until%             the interpolation looks reasonable.%             % HISTORY:  1. Version 1 written 27 June 1990 by Gary T. Mitchum.%              if nargin<3; disp('Routine ARINTERP: Must input ALL arguments.'); return; endx=y;[mrow,ncol]=size(y); tagend=NaN*ones(maxgap+1,ncol); x=[x;tagend]; x=x(:);n=length(x); i = find(~isnan(x)); maxi=max(i);for j=i(1):maxi  for kk=j:j	if isnan(x(j))	  b = j;	  for jj=b:n		if isnan(x(jj))~=1; e = jj-1; break; end	  end	  if j==maxi & e~=n-1; break; end	  if (e-b)<maxgap		n1=b-ntrain; n2=e+ntrain; 		if n1<1 | n2>n; break; end		x1=x(n1:b-1); x2=x(n2:-1:e+1); lengap=e-b+1;		ck=sum(isnan(x1+x2));		if ck==0          [mac1,ar1]=armodel(x1); [mac2,ar2]=armodel(x2);          lenar1=length(ar1); lenar2=length(ar2);          for ngap=1:lengap      		x1(ntrain+ngap)=mac1+sum(x1(ntrain-1+ngap:-1:ntrain+ngap-lenar1).*ar1);      		x2(ntrain+ngap)=mac2+sum(x2(ntrain-1+ngap:-1:ntrain+ngap-lenar2).*ar2);          end          x1gap=x1(ntrain+1:ntrain+lengap); x2gap=x2(ntrain+1:ntrain+lengap);          wt1=ones(lengap,1)./[1:lengap]'; wt2=wt1;          x2gap(lengap:-1:1)=x2gap; wt2(lengap:-1:1)=wt2;          x(b:e) = (wt1.*x1gap + wt2.*x2gap) ./ (wt1 + wt2);        end      end    end  endendx=reshape(x,mrow+maxgap+1,ncol); x=x(1:mrow,1:ncol);
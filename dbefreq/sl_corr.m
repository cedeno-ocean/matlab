function [r95,se,neff] = sl_corr(X,Y,ssize)%Function [R95,SE,Neff] = sl_corr(X,Y,ssize)%% Calculate significance levels for correlation coefficients by % the random phase method (Ebisuzaki, 1997). Calls R_PHAS, STER.% Enter with two equal-sized matrices X(N,M), Y(N,M) whose% columns are M signals of N observations each, thought to be% serially correlated. If X is a vector, then all columns of Y% are correlated against X. Else, calculate the significance level% for corresponding columns. %% The outputs are vectors of dimension M or <ssize>*M/100, as follows:%    R95 = 95% significance level%    SE  = large-lag standard error%    Neff = effective degrees of freedom%% For values of M greater than 50, the calculations are done only % for a random subsample (0.1*M) of the series (default). The opt-% tional <ssize> parameter, expressed as % of M, is available to change % the size of the subsample. Subsampling is done because the calculations% of the random phase method are intensive and for large arrays they% are time consuming. The assumption behind the subsampling is that% the integral time scale of the data does not vary greatly over the % domain of M. To override subsampling entirely, set <ssize> = 100. %% What is frequently required is to take the average of R95 and to judge% its uncertainty from std(R95). %% D.B. Enfield, NOAA/AOML, coded June 2000% Calls R_PHAS, STER% Ebisuzaki, W., 1997: Jounal of Climate, 10: 2147-2153.t0 = clock;% Determine if X is a vector or matrix[nr,nc] = size(Y);if size(X,2) == 1 & nc > 1	X = X*ones(1,nc); elseif size(X,2) ~= nc, 	disp(['X & Y are not the same size or X is not a vector'])end% Subsample the data (if needed)if nargin < 3 & nc >= 50	ssize = 10;elseif nargin < 3 & nc < 50	ssize = 100;endssize = fix(nc*ssize/100);%disp(['The sample size is ',int2str(ssize)])jy = ceil(nc*rand(ssize,1)); % random index for YX = X(:,jy); Y = Y(:,jy);% Series lengths must be evenif nr ~= 2*floor(nr/2)	X(nr,:) = [];	Y(nr,:) = [];end% Initialize the dataX = X - ones(length(X(:,1)),1)*meanmiss(X);  % remove means of XY = Y - ones(length(Y(:,1)),1)*meanmiss(Y);  % remove means of YX = nan2miss(X,0); Y = nan2miss(Y,0);        % NaNs to zeros% If desired, also calculate the large-lag standard error amd the% effective degrees of freedom by the autocorrelation method (Davis).if nargout >= 2	se = ster(X,Y);	neff = 1./se.^2;end	% Calculate the correlations with phase-randomized Xnrep = 50;  % number of randomized replications of X[nr,nc] = size(X);rho = nan*ones(nrep,nc); r95 = nan*ones(1,nc); for j = 1:ssize%	disp(['Doing sample column # ',int2str(j)])	Xj = X(:,j)*ones(1,nrep); %size(Xj), size(Y)	Xj = r_phas(Xj);          %size(Xj), size(Y)	xycov = Y(:,j)'*Xj;	sx = sum(Xj.*Xj);	sy = Y(:,j)'*Y(:,j);	rho(:,j) = abs(xycov./sqrt(sx*sy))';	rho(:,j) = sort(rho(:,j)); 	r95(j) = rho(floor(.95*nrep),j);endnmin = floor(etime(clock,t0)/60); nsec = etime(clock,t0) - 60*nmin;%disp(['Execution time = ',int2str(nmin),' minutes, ',num2str(nsec),' seconds']); return